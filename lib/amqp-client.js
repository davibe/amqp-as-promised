// Generated by CoffeeScript 1.7.1
(function() {
  var ExchangeWrapper, Q, QueueWrapper, amqp, log;

  log = require('bog');

  Q = require('q');

  amqp = require('amqp');

  ExchangeWrapper = require('./exchange-wrapper');

  QueueWrapper = require('./queue-wrapper');

  module.exports = function(conf) {
    var bind, conn, exchange, isShutdown, local, queue, shutdown, shutdownDef, unbind, _self;
    local = conf.local || process.env.LOCAL;
    if (local) {
      log.info("local means no amqp connection");
    }
    isShutdown = null;
    conn = (function() {
      var def, mq, _ref;
      if (local) {
        return Q({
          local: true
        });
      }
      log.info("Connecting", conf.connection);
      def = Q.defer();
      mq = amqp.createConnection(conf.connection);
      mq._ttQueues = (_ref = mq._ttQueues) != null ? _ref : {};
      mq.on('ready', function(ev) {
        log.info('amqp connection ready');
        return def.resolve(mq);
      });
      mq.on('error', function(err) {
        if (def.promise.isPending()) {
          def.reject(err);
          mq.backoff = mq.reconnect = function() {
            return false;
          };
          return log.warn('amqp connection failed:', err);
        } else if (def.promise.isFulfilled()) {
          if (!isShutdown) {
            return log.warn('amqp error:', (err.message ? err.message : err));
          }
        }
      });
      return def.promise;
    })();
    exchange = function(name, opts) {
      var def;
      if (name instanceof ExchangeWrapper) {
        return Q(name);
      }
      if (local) {
        throw new Error('Unable connect exchange when local');
      }
      if (isShutdown) {
        throw new Error('Unable connect exchange when shutdown');
      }
      def = Q.defer();
      conn.then(function(mq) {
        var prom, _ref;
        mq._ttExchanges = (_ref = mq._ttExchanges) != null ? _ref : {};
        prom = mq._ttExchanges[name];
        if (prom) {
          return prom.then(function(ex) {
            return def.resolve(ex);
          });
        }
        mq._ttExchanges[name] = def.promise;
        opts = opts != null ? opts : {
          passive: true
        };
        if (name !== '') {
          opts.confirm = true;
        }
        return mq.exchange(name, opts, function(ex) {
          log.info('exchange ready:', ex.name);
          return def.resolve(new ExchangeWrapper(ex));
        }).on('error', function(err) {
          return def.reject(err);
        });
      }).done();
      return def.promise;
    };
    queue = (function(_this) {
      return function(qname, opts) {
        var def;
        if (qname instanceof QueueWrapper) {
          return Q(qname);
        }
        if (local) {
          throw new Error('Unable to connect queue when local');
        }
        if (isShutdown) {
          throw new Error('Unable to connect queue shutdown');
        }
        if (qname !== null && typeof qname === 'object') {
          opts = qname;
          qname = '';
        }
        if (!qname) {
          qname = '';
        }
        opts = opts != null ? opts : qname === '' ? {
          exclusive: true
        } : {
          passive: true
        };
        def = Q.defer();
        conn.then(function(mq) {
          var prom;
          if (qname !== '') {
            prom = mq._ttQueues[qname];
            if (prom) {
              return prom.then(function(q) {
                return def.resolve(q);
              });
            }
            mq._ttQueues[qname] = def.promise;
          }
          return mq.queue(qname, opts, function(queue) {
            log.info('queue created:', queue.name);
            if (qname === '') {
              mq._ttQueues[queue.name] = def.promise;
            }
            return def.resolve(new QueueWrapper(_self, queue));
          }).on('error', function(err) {
            return def.reject(err);
          });
        }).done();
        return def.promise;
      };
    })(this);
    bind = function(ex, q, topic, callback) {
      var def;
      if (local) {
        throw new Error('Unable to bind when local');
      }
      if (isShutdown) {
        throw new Error('Unable to bind when shutdown');
      }
      if (typeof topic === 'function') {
        callback = topic;
        topic = q;
        q = '';
      }
      if (!q) {
        q = '';
      }
      def = Q.defer();
      (Q.all([exchange(ex), queue(q)])).spread(function(ex, q) {
        return Q.fcall(function() {
          return q.bind(ex, topic);
        }).then(function(q) {
          if (callback != null) {
            return q.subscribe(callback);
          }
        }).then(function() {
          return def.resolve(q.name);
        });
      }).fail(function(err) {
        return def.reject(err);
      }).done();
      return def.promise;
    };
    unbind = function(qname) {
      var def;
      def = Q.defer();
      conn.then(function(mq) {
        var qp;
        if (mq.local) {
          return def.resolve(true);
        }
        qp = mq._ttQueues[qname];
        if (!qp) {
          return def.resolve(mq);
        }
        return qp;
      }).then(function(q) {
        return q.unbind();
      }).then(function(q) {
        return q.unsubscribe();
      }).then(function() {
        return def.resolve(qname);
      }).fail(function(err) {
        return def.reject(err);
      }).done();
      return def.promise;
    };
    shutdownDef = null;
    shutdown = function() {
      var def;
      if (isShutdown) {
        return isShutdown.promise;
      }
      def = isShutdown = Q.defer();
      conn.then(function(mq) {
        var qname, qp, todo;
        if (mq.local) {
          return def.resolve(true);
        }
        todo = (function() {
          var _ref, _results;
          _ref = mq._ttQueues;
          _results = [];
          for (qname in _ref) {
            qp = _ref[qname];
            _results.push(qp.then(function(queue) {
              if (queue.isAutoDelete()) {
                return unbind(qname);
              }
            }));
          }
          return _results;
        })();
        return Q.all(todo).then(function() {
          log.info('closing amqp connection');
          mq.backoff = mq.reconnect = mq.connect = function() {
            return false;
          };
          mq.end();
          log.info('amqp closed');
          return def.resolve(true);
        });
      }).done();
      return def.promise;
    };
    return _self = {
      exchange: exchange,
      queue: queue,
      bind: bind,
      shutdown: shutdown,
      local: local
    };
  };

}).call(this);

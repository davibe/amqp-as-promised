// Generated by CoffeeScript 1.7.1
(function() {
  var Cache, DEFAULT_TIMEOUT, Q, Rpc, compress, decompress, merge, uuid, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Q = require('q');

  uuid = require('uuid');

  Cache = require('mem-cache');

  merge = require('./merge');

  _ref = require('./compressor'), compress = _ref.compress, decompress = _ref.decompress;

  DEFAULT_TIMEOUT = 1000;

  module.exports = Rpc = (function() {
    function Rpc(amqpc, options) {
      var _ref1;
      this.amqpc = amqpc;
      this.options = options;
      this.rpc = __bind(this.rpc, this);
      this.resolveResponse = __bind(this.resolveResponse, this);
      this.registerResponse = __bind(this.registerResponse, this);
      this.returnChannel = __bind(this.returnChannel, this);
      this.timeout = ((_ref1 = this.options) != null ? _ref1.timeout : void 0) || DEFAULT_TIMEOUT;
      this.responses = new Cache({
        timeout: this.timeout
      });
      this.responses.on('expired', function(ev) {
        var _ref2, _ref3;
        if (typeof (ev != null ? (_ref2 = ev.value) != null ? _ref2.def.reject : void 0 : void 0) === 'function') {
          return ev.value.def.reject(new Error("timeout: " + ((_ref3 = ev.value.options) != null ? _ref3.info : void 0)));
        }
      });
    }

    Rpc.prototype.returnChannel = function() {
      if (!this._returnChannel) {
        this._returnChannel = this.amqpc.queue('', {
          autoDelete: true,
          exclusive: true
        });
        this._returnChannel.then((function(_this) {
          return function(q) {
            return q.subscribe(function(msg, headers, deliveryInfo) {
              if (deliveryInfo != null) {
                return _this.resolveResponse(deliveryInfo.correlationId, msg, headers);
              }
            });
          };
        })(this));
      }
      return this._returnChannel;
    };

    Rpc.prototype.registerResponse = function(corrId, options) {
      var def, value;
      def = Q.defer();
      options = options || {};
      value = {
        def: def,
        options: options
      };
      this.responses.set(corrId, value, options.timeout);
      return def;
    };

    Rpc.prototype.resolveResponse = function(corrId, msg, headers) {
      var ct, p, prgsSeq, response, _ref1, _ref2;
      _ref1 = corrId.split('#x-progress:'), corrId = _ref1[0], prgsSeq = _ref1[1];
      if (response = this.responses.get(corrId)) {
        _ref2 = decompress(msg, headers), ct = _ref2[0], p = _ref2[1];
        return p.then((function(_this) {
          return function(payload) {
            if (prgsSeq) {
              return response.def.notify(payload);
            } else {
              _this.responses.remove(corrId);
              return response.def.resolve(payload);
            }
          };
        })(this)).fail(function(err) {
          return response.def.reject(err);
        });
      }
    };

    Rpc.prototype.rpc = function(exchange, routingKey, msg, headers, options) {
      if (!msg) {
        throw new Error('Must provide msg');
      }
      return Q.all([this.amqpc.exchange(exchange), this.returnChannel()]).spread((function(_this) {
        return function(ex, q) {
          var corrId, def, h, opts, p, timeout, _ref1;
          corrId = uuid.v4();
          options = options || {};
          options.info = options.info || ("" + ex.name + "/" + routingKey);
          timeout = options.timeout || _this.timeout;
          def = _this.registerResponse(corrId, options);
          opts = {
            deliveryMode: 1,
            replyTo: q.name,
            correlationId: corrId,
            expiration: "" + timeout
          };
          opts.headers = headers || {};
          opts.headers.timeout = timeout;
          _ref1 = compress(msg, options), h = _ref1[0], p = _ref1[1];
          merge(opts.headers, h);
          return p.then(function(payload) {
            return ex.publish(routingKey, payload, opts);
          }).then(function() {
            return def.promise;
          });
        };
      })(this));
    };

    return Rpc;

  })();

}).call(this);

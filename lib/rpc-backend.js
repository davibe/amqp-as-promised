// Generated by CoffeeScript 1.7.1
(function() {
  var Q, RpcBackend, compress, decompress, log, merge, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  log = require('bog');

  Q = require('q');

  merge = require('./merge');

  _ref = require('./compressor'), compress = _ref.compress, decompress = _ref.decompress;

  module.exports = RpcBackend = (function() {
    function RpcBackend(amqpc) {
      this.amqpc = amqpc;
      this.serve = __bind(this.serve, this);
    }

    RpcBackend.prototype.serve = function(exname, topic, callback) {
      return Q.all([
        this.amqpc.exchange(exname, {
          type: 'topic',
          durable: true,
          autoDelete: false
        }), this.amqpc.exchange(''), this.amqpc.queue("" + exname + "." + topic, {
          durable: true,
          autoDelete: false
        })
      ]).spread((function(_this) {
        return function(ex, defaultex, queue) {
          queue.bind(ex, topic);
          return queue.subscribe(_this._mkcallback(defaultex, callback));
        };
      })(this));
    };

    RpcBackend.prototype._mkcallback = function(exchange, handler) {
      return function(msg, headers, info) {
        var ct, opts, p, progress, timeout, timestamp, _ref1, _ref2;
        if (info.replyTo == null) {
          return;
        }
        timestamp = (_ref1 = headers != null ? headers.timestamp : void 0) != null ? _ref1 : (info != null ? info.timestamp : void 0) * 1000;
        timeout = headers != null ? headers.timeout : void 0;
        if (timestamp && timeout) {
          if (typeof timestamp === 'string') {
            timestamp = new Date(timestamp).getTime();
          }
          if (Date.now() > timestamp + timeout) {
            log.info("Discarding timed out message (" + info.replyTo + ", " + info.correlationId + ")");
            return;
          }
        }
        opts = {};
        if (info.correlationId != null) {
          opts.correlationId = info.correlationId;
        }
        progress = [];
        _ref2 = decompress(msg, headers), ct = _ref2[0], p = _ref2[1];
        merge(info, ct);
        return p.then(function(payload) {
          return Q.when(handler(payload, headers, info, function(prgs) {
            var h, popts, prev, _ref3, _ref4;
            if (!info.correlationId) {
              return;
            }
            popts = {
              correlationId: info.correlationId + "#x-progress:" + progress.length
            };
            _ref3 = compress(prgs, headers), h = _ref3[0], p = _ref3[1];
            if (h) {
              opts.headers = h;
            }
            prev = (_ref4 = progress[progress.length - 1]) != null ? _ref4 : Q();
            return progress.push(Q.all([prev, p]).spread(function(_, payload) {
              return exchange.publish(info.replyTo, payload, popts);
            }));
          }));
        }).then(function(res) {
          var h, _ref3;
          _ref3 = compress(res, headers), h = _ref3[0], p = _ref3[1];
          if (h) {
            opts.headers = h;
          }
          return p;
        }).then(function(res) {
          return Q.all(progress).then(function() {
            return exchange.publish(info.replyTo, res, opts);
          });
        }).fail(function(err) {
          log.error(err);
          return exchange.publish(info.replyTo, {
            error: err.message
          }, opts);
        }).fail(function(err) {
          return log.error(err);
        });
      };
    };

    return RpcBackend;

  })();

}).call(this);
